#! /usr/bin/python3

import argparse
import collections
import textwrap

import yaml

HEADER = textwrap.dedent("""\
/*
    ChibiOS - Copyright (C) 2006..2016 Giovanni Di Sirio
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/*
    Generated by gen-board.h.py based on {yamlfile}
*/

#ifndef _BOARD_H_
#define _BOARD_H_


/*
    Setup for {name}
*/

/*
    Board identifier
*/
#define BOARD_
#define BOARD_NAME                     "{name}"

/*
    Board oscillators-related settings.
*/
#if !defined(STM32_LSECLK)
#define STM32_LSECLK                   {lsefreq}U
#endif

#if !defined(STM32_HSECLK)
#define STM32_HSECLK                   {hsefreq}U
#endif

/*
    Board voltages
    Required for performance limits calculation.
*/
#define STM32_VDD                      {voltage}U

/*
    MCU type as defined in the ST header.
*/
#define {mcutype}

""")

IO_PORT_SETUP = textwrap.dedent("""\
/*
    I/O ports initial setup, this configuration is established soon after reset
    in the initialization code.
     Please refer to the STM32 Reference Manual for details.
*/
#define PIN_MODE_INPUT(n)              (0U << ((n) * 2U))
#define PIN_MODE_OUTPUT(n)             (1U << ((n) * 2U))
#define PIN_MODE_ALTERNATE(n)          (2U << ((n) * 2U))
#define PIN_MODE_ANALOG(n)             (3U << ((n) * 2U))
#define PIN_ODR_LOW(n)                 (0U << (n))
#define PIN_ODR_HIGH(n)                (1U << (n))
#define PIN_OTYPE_PUSHPULL(n)          (0U << (n))
#define PIN_OTYPE_OPENDRAIN(n)         (1U << (n))
#define PIN_OSPEED_VERYLOW(n)          (0U << ((n) * 2U))
#define PIN_OSPEED_LOW(n)              (1U << ((n) * 2U))
#define PIN_OSPEED_MEDIUM(n)           (2U << ((n) * 2U))
#define PIN_OSPEED_HIGH(n)             (3U << ((n) * 2U))
#define PIN_PUPDR_FLOATING(n)          (0U << ((n) * 2U))
#define PIN_PUPDR_PULLUP(n)            (1U << ((n) * 2U))
#define PIN_PUPDR_PULLDOWN(n)          (2U << ((n) * 2U))
#define PIN_AFIO_AF(n, v)              ((v) << (((n) % 8U) * 4U))

""")

FOOTER = textwrap.dedent("""\
#if !defined(_FROM_ASM_)
#ifdef __cplusplus
extern "C" {
#endif
  void boardInit(void);
#ifdef __cplusplus
}
#endif
#endif /* _FROM_ASM_ */

#endif /* _BOARD_H_ */""")


def write_io_pins(board, board_def):
    IO_BANKS = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
    PINS_PER_BANK = 16

    pins = {k: ["PIN{}".format(n) for n in range(PINS_PER_BANK)]
            for k in IO_BANKS}

    for pin_def in board_def['pins']:
        name, port, num, *_ = pin_def.split(",")
        pins[port.upper()][int(num)] = name.upper()

    board.write(textwrap.dedent("""\
        /*
            IO pins assignments.
        */

        """))

    for port in IO_BANKS:
        for num, name in enumerate(pins[port]):
            board.write("#define GPIO{port}_{name}{pad}{num}U\n".format(
                port=port,
                name=name,
                num=num,
                # Pad line to start the pin number at 40 chars
                pad=" "*(39-14-len(name))))
        board.write("\n")


def write_io_lines(board, board_def):
    board.write(textwrap.dedent("""\
    /*
        IO lines assignments.
    */

    """))

    for pin_def in board_def['pins']:
        name, port, num, *_ = pin_def.split(",")
        board.write(
            "#define LINE_{name}{pad}PAL_LINE(GPIO{port}, {num}U)\n".format(
                name=name.upper(),
                port=port.upper(),
                num=num,
                # Pad line to start PAL_LINE at 40 chars
                pad=" "*(39-13-len(name))))
    board.write("\n")


def write_io_ports(board, board_def):
    default_pin = board_def['default_modes'].split(",")



def process_yaml(board_def):

    # Voltages in the form 330 (3v3), 500 (5v)
    board_def['voltage'] = int(board_def['voltage']*100)
    return board_def


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("yamlfile",
                        help="YAML board definition fle to read.")
    parser.add_argument("outfile", nargs="?", default="board.h",
                        help="File to write to. [board.h]")

    return parser.parse_args()


def main():
    args = get_args()

    with open(args.yamlfile, "r") as def_file:
        board_def = yaml.load(def_file)

    board_def = process_yaml(board_def)

    with open(args.outfile, "w") as board:
        board.write(HEADER.format(yamlfile=args.yamlfile,
                                  **board_def))

        write_io_pins(board, board_def)

        write_io_lines(board, board_def)

        board.write(IO_PORT_SETUP)

        write_io_ports(board, board_def)

        board.write(FOOTER)

if __name__ == "__main__":
    main()
